#!/bin/sh

. /etc/rc.conf

upgrade_moduli()
{
  local old_file="$1" new_file="$2" old_ver new_ver

  if [ ! -f "$old_file" ]; then
    return 0
  fi

  old_ver="$(sed -n -r -e '1 s/^#.* moduli,v ([0-9.]+) .*$/\1/p' "$old_file")"
  new_ver="$(sed -n -r -e '1 s/^#.* moduli,v ([0-9.]+) .*$/\1/p' "$new_file")"

  if [ "$old_ver" != "$new_ver" ]; then
    return 0
  fi

  return 1
}

init () {
  mkdir -p /var/run/sshd

  if [ -d /mnt/kd/ssh ]; then
    ln -snf /mnt/kd/ssh /tmp/etc/ssh
  else
    mkdir /tmp/etc/ssh
  fi

  PORT="${SSHDPORT:-22}"

  if [ -f /mnt/kd/sshd.conf ]; then
    cp /mnt/kd/sshd.conf /tmp/etc/ssh/sshd_config
  else
    echo "# Autogenerated.  Do not edit.
# A manually generated sshd_config will use /mnt/kd/sshd.conf if it exists.
" > /tmp/etc/ssh/sshd_config

    echo "Protocol 2
Port $PORT" >> /tmp/etc/ssh/sshd_config

    if [ "$IPV6" = "yes" ]; then
      echo "ListenAddress ::" >> /tmp/etc/ssh/sshd_config
    fi
    echo "ListenAddress 0.0.0.0" >> /tmp/etc/ssh/sshd_config

    echo "
PermitRootLogin ${SSHDROOT:-yes}
PasswordAuthentication ${SSHD_PASS_AUTH:-yes}
ChallengeResponseAuthentication no

UseDNS no
PubkeyAcceptedKeyTypes +ssh-dss

IPQoS		cs2 af41

Subsystem       sftp    /usr/libexec/sftp-server" >> /tmp/etc/ssh/sshd_config

    if [ -f /etc/issue.net ]; then
      echo "Banner /etc/issue.net" >> /tmp/etc/ssh/sshd_config
    fi
    if [ -n "$SSHD_ALLOW_USERS" ]; then
      echo "AllowUsers $SSHD_ALLOW_USERS" >> /tmp/etc/ssh/sshd_config
    fi
  fi

  # if it's not a link (to /mnt/kd) then populate it from /stat/etc/ssh
  if [ ! -L /tmp/etc/ssh ]; then
    cp -a /stat/etc/ssh/* /tmp/etc/ssh/
  else
    if upgrade_moduli /tmp/etc/ssh/moduli /stat/etc/ssh/moduli; then
      echo "Upgrading ssh DH groups in /etc/ssh/moduli"
      cp -p /stat/etc/ssh/moduli /tmp/etc/ssh/moduli
    fi
  fi

  # Generate server keys
  unset IFS
  for i in ssh_host_rsa_key ssh_host_dsa_key ssh_host_ecdsa_key ssh_host_ed25519_key; do
    file="/tmp/etc/ssh/$i"
    if [ ! -f "$file" ]; then
      msg="Generating ssh server public/private key type:"
      case $i in
        ssh_host_rsa_key)
          echo -n "$msg rsa..."
          /usr/bin/ssh-keygen -q -t rsa -f "$file" -N ''
          ;;
        ssh_host_dsa_key)
          echo -n "$msg dsa..."
          /usr/bin/ssh-keygen -q -t dsa -f "$file" -N ''
          ;;
        ssh_host_ecdsa_key)
          echo -n "$msg ecdsa..."
          /usr/bin/ssh-keygen -q -t ecdsa -f "$file" -N ''
          ;;
        ssh_host_ed25519_key)
          echo -n "$msg ed25519..."
          /usr/bin/ssh-keygen -q -t ed25519 -f "$file" -N ''
          ;;
      esac
      echo " done."
    fi
  done

  # in case /root isn't persistent.
  if [ ! -d /root/.ssh ]; then
    mkdir /root/.ssh
  fi

  if [ ! -f /root/.ssh/authorized_keys ]; then
    if [ -d /stat/etc/ssh_keys ]; then
      for i in $(ls /stat/etc/ssh_keys); do
        if [ -f "/stat/etc/ssh_keys/${i}" ]; then
          cat "/stat/etc/ssh_keys/${i}" >> /root/.ssh/authorized_keys
        fi
      done
    fi

    if [ -d /mnt/kd/ssh_keys ]; then
      for i in $(ls /mnt/kd/ssh_keys); do
        if [ -f "/mnt/kd/ssh_keys/${i}" ]; then
          cat "/mnt/kd/ssh_keys/${i}" >> /root/.ssh/authorized_keys
        fi
      done
    fi
  fi

  # Automatically create "/mnt/kd/ssh_root_keys" directory if it doesn't exist
  if [ ! -d /mnt/kd/ssh_root_keys ]; then
    mkdir /mnt/kd/ssh_root_keys 2>/dev/null     # will fail on virgin RO filesystem, ignore stderr
  fi

  # Generate root user keys
  if [ -d /mnt/kd/ssh_root_keys ]; then
    for i in id_rsa id_ecdsa id_ed25519; do
      file="/mnt/kd/ssh_root_keys/$i"
      if [ ! -f "$file" ]; then
        msg="Generating ssh root user public/private key type:"
        case $i in
          id_rsa)
            echo -n "$msg rsa..."
            # run in a background process since RSA takes a long time...
            (
              nice /usr/bin/ssh-keygen -q -t rsa -f "$file" -N ''
              if [ ! -f /root/.ssh/id_rsa ]; then
                cp -p "$file"* /root/.ssh/
              fi
            ) >/dev/null 2>&1 &
            ;;
          id_ecdsa)
            echo -n "$msg ecdsa..."
            /usr/bin/ssh-keygen -q -t ecdsa -f "$file" -N ''
            ;;
          id_ed25519)
            echo -n "$msg ed25519..."
            /usr/bin/ssh-keygen -q -t ed25519 -f "$file" -N ''
            ;;
        esac
        echo " done."
      fi
    done
  fi

  for i in rsa dsa ecdsa ed25519; do
    if [ ! -f "/root/.ssh/id_${i}" ]; then
      if [ -f "/mnt/kd/ssh_root_keys/id_${i}" ]; then
        cp -p "/mnt/kd/ssh_root_keys/id_${i}"* /root/.ssh/
      fi
    fi
  done
}

start () {
  if [ -f /etc/ssh/ssh_host_rsa_key ]; then
    echo "Starting sshd..."
    /usr/sbin/sshd
  fi
}

stop () {
  if [ -f /var/run/sshd.pid ]; then
    echo "Stopping sshd..."
    kill $(cat /var/run/sshd.pid)
  fi
}

close () {
  local pid ssh_pids cnt=0

  ssh_pids="$(pgrep -f '^sshd:.*@')"
  for pid in $ssh_pids; do
    if kill $pid; then
      cnt=$((cnt + 1))
    fi
  done
  if [ $cnt -gt 0 ]; then
    echo "Closed $cnt SSH connection(s)..."
  fi
}

case $1 in

start)
  start
  ;;

stop)
  stop
  ;;

init)
  init
  start
  ;;

restart)
  stop
  sleep 2
  start
  ;;

close)
  close
  ;;

*)
  echo "Usage: start|stop|restart|close"
  ;;

esac
