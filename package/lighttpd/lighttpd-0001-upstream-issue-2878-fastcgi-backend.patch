From 210b57708e9802dc5738eeb316500403b69ae52e Mon Sep 17 00:00:00 2001
From: Glenn Strauss <gstrauss@gluelogic.com>
Date: Sun, 18 Mar 2018 19:01:32 -0400
Subject: [PATCH] [core] fix rare race condition from backends (fixes #2878)

fix rare race condition from backends with server.stream-response-body=2

(thx abelbeck)

x-ref:
  "fastcgi and stream-response-body=2 hangs on last chunk"
  https://redmine.lighttpd.net/issues/2878
---
 src/fdevent.h          | 5 +++--
 src/gw_backend.c       | 4 ++++
 src/http-header-glue.c | 7 +++++--
 src/mod_cgi.c          | 4 ++++
 src/mod_fastcgi.c      | 6 +++++-
 5 files changed, 21 insertions(+), 5 deletions(-)

diff --git a/src/fdevent.h b/src/fdevent.h
index 44dbbb9d..32a45abe 100644
--- a/src/fdevent.h
+++ b/src/fdevent.h
@@ -25,8 +25,9 @@ typedef handler_t (*fdevent_handler)(struct server *srv, void *ctx, int revents)
 #define FDEVENT_STREAM_REQUEST_BUFMIN   BV(1)
 #define FDEVENT_STREAM_REQUEST_POLLIN   BV(15)
 
-#define FDEVENT_STREAM_RESPONSE         BV(0)
-#define FDEVENT_STREAM_RESPONSE_BUFMIN  BV(1)
+#define FDEVENT_STREAM_RESPONSE           BV(0)
+#define FDEVENT_STREAM_RESPONSE_BUFMIN    BV(1)
+#define FDEVENT_STREAM_RESPONSE_POLLRDHUP BV(15)
 
 int fdevent_config(server *srv);
 const char * fdevent_show_event_handlers(void);
diff --git a/src/gw_backend.c b/src/gw_backend.c
index d681cf9a..1abe97bc 100644
--- a/src/gw_backend.c
+++ b/src/gw_backend.c
@@ -2164,9 +2164,13 @@ static handler_t gw_handle_fdevent(server *srv, void *ctx, int revents) {
              * since event loop will spin on fd FDEVENT_HUP event
              * until unregistered. */
             handler_t rc;
+            const unsigned short flags = con->conf.stream_response_body;
+            con->conf.stream_response_body &= ~FDEVENT_STREAM_RESPONSE_BUFMIN;
+            con->conf.stream_response_body |= FDEVENT_STREAM_RESPONSE_POLLRDHUP;
             do {
                 rc = gw_recv_response(srv,hctx); /*(might invalidate hctx)*/
             } while (rc == HANDLER_GO_ON);       /*(unless HANDLER_GO_ON)*/
+            con->conf.stream_response_body = flags;
             return rc; /* HANDLER_FINISHED or HANDLER_ERROR */
         } else {
             gw_proc *proc = hctx->proc;
diff --git a/src/http-header-glue.c b/src/http-header-glue.c
index 0e448090..6135c1da 100644
--- a/src/http-header-glue.c
+++ b/src/http-header-glue.c
@@ -1213,8 +1213,11 @@ handler_t http_response_read(server *srv, connection *con, http_response_opts *o
                   ? HANDLER_FINISHED  /* read finished */
                   : HANDLER_GO_ON;    /* optimistic read; data not ready */
               #else
-                if (!(fdevent_event_get_interest(srv->ev, fd) & FDEVENT_IN))
-                    return HANDLER_GO_ON; /* optimistic read; data not ready */
+                if (!(fdevent_event_get_interest(srv->ev, fd) & FDEVENT_IN)) {
+                    if (!(con->conf.stream_response_body
+                          & FDEVENT_STREAM_RESPONSE_POLLRDHUP))
+                        return HANDLER_GO_ON;/*optimistic read; data not ready*/
+                }
                 toread = 4096; /* let read() below indicate if EOF or EAGAIN */
               #endif
             }
diff --git a/src/mod_cgi.c b/src/mod_cgi.c
index dd788308..047b3d83 100644
--- a/src/mod_cgi.c
+++ b/src/mod_cgi.c
@@ -425,9 +425,13 @@ static handler_t cgi_handle_fdevent(server *srv, void *ctx, int revents) {
 			 * since event loop will spin on fd FDEVENT_HUP event
 			 * until unregistered. */
 			handler_t rc;
+			const unsigned short flags = con->conf.stream_response_body;
+			con->conf.stream_response_body &= ~FDEVENT_STREAM_RESPONSE_BUFMIN;
+			con->conf.stream_response_body |= FDEVENT_STREAM_RESPONSE_POLLRDHUP;
 			do {
 				rc = cgi_recv_response(srv,hctx);/*(might invalidate hctx)*/
 			} while (rc == HANDLER_GO_ON);           /*(unless HANDLER_GO_ON)*/
+			con->conf.stream_response_body = flags;
 			return rc; /* HANDLER_FINISHED or HANDLER_COMEBACK or HANDLER_ERROR */
 		} else if (!buffer_string_is_empty(hctx->response)) {
 			/* unfinished header package which is a body in reality */
diff --git a/src/mod_fastcgi.c b/src/mod_fastcgi.c
index 4ad4f83d..b442214e 100644
--- a/src/mod_fastcgi.c
+++ b/src/mod_fastcgi.c
@@ -368,7 +368,10 @@ static handler_t fcgi_recv_parse(server *srv, connection *con, struct http_respo
 	int fin = 0;
 
 	if (0 == n) {
-		if (!(fdevent_event_get_interest(srv->ev, hctx->fd) & FDEVENT_IN)) return HANDLER_GO_ON;
+		if (-1 == hctx->request_id) return HANDLER_FINISHED; /*(flag request ended)*/
+		if (!(fdevent_event_get_interest(srv->ev, hctx->fd) & FDEVENT_IN)
+		    && !(con->conf.stream_response_body & FDEVENT_STREAM_RESPONSE_POLLRDHUP))
+			return HANDLER_GO_ON;
 		log_error_write(srv, __FILE__, __LINE__, "ssdsb",
 				"unexpected end-of-file (perhaps the fastcgi process died):",
 				"pid:", hctx->proc->pid,
@@ -436,6 +439,7 @@ static handler_t fcgi_recv_parse(server *srv, connection *con, struct http_respo
 
 			break;
 		case FCGI_END_REQUEST:
+			hctx->request_id = -1; /*(flag request ended)*/
 			fin = 1;
 			break;
 		default:
