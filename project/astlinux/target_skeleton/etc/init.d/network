#!/bin/bash

. /etc/rc.conf

. /etc/init.d/functions.d/network
. /etc/init.d/functions.d/misc

nthfield()
{
  echo "${!1}" | cut "-d$2" "-f$3"
}

create_nasX()
{
  local name list type tag value VPI VCI ATMINFO CARD IF="$1" IFS

  CARD="${IF:3:1}"

  if [ -n "$ATM_MODULE" ]; then
    modprobe $ATM_MODULE
  fi

  name="ATM_PARAMS${CARD}"
  ATM_PARAMS="${!name}"

  # initialize any values
  IFS=$'\n'
  for list in $ATM_PARAMS; do
    type="$(nthfield list ~ 1)"
    tag="$(nthfield list ~ 2)"
    value="$(nthfield list ~ 3)"
    case $type in
    solos)
      soloscli -s $CARD "$tag" "$value"
      ;;
    esac
  done

  name="ATM_CIRCUIT${CARD}"
  ATMINFO="${!name}"

  if [ -z "$ATMINFO" ]; then
    echo "Need VPI/VCI information for interface $PPPOEIF ($name)." >&2
    return 1
  fi

  VPI="$(echo $ATMINFO | cut -d. -f1)"
  VCI="$(echo $ATMINFO | cut -d. -f2)"

  br2684ctl -b -c "$CARD" -e 0 -p 1 -s 2040 -a "$CARD.$VPI.$VCI"

  ip link set dev "$IF" up

  return 0
}

gen_nopd_dhcp6c_conf()
{
  local interface="$1"

  echo "# Autogenerated.  Do not edit.
interface $interface {
  send ia-na 1;
  send rapid-commit;
};

id-assoc na 1 { };"

}

gen_dhcp6c_conf()
{
  local interface="$1" dummy=0 len id iname int IFS

  len="${DHCPV6_CLIENT_PREFIX_LEN:-60}"

  # Sanity check the prefix length
  if [ $len -lt 8 -o $len -gt 64 ]; then
    len="60"
  fi

  echo "# Autogenerated.  Do not edit.
interface $interface {"
  if [ "$DHCPV6_CLIENT_REQUEST_ADDRESS" != "no" ]; then
    echo "  send ia-na 1;"
  fi
  if [ "$DHCPV6_CLIENT_REQUEST_PREFIX" != "no" ]; then
    echo "  send ia-pd 1;"
  fi
  echo "  send rapid-commit;"
  echo "  script \"/etc/dhcp6c.script\";"
  echo "};"

  if [ "$DHCPV6_CLIENT_REQUEST_ADDRESS" != "no" ]; then
    echo "
id-assoc na 1 { };"
  fi

  if [ "$DHCPV6_CLIENT_REQUEST_PREFIX" != "no" ]; then
    echo "
id-assoc pd 1 {"
    if [ "$DHCPV6_CLIENT_PREFIX_HINT" != "no" ]; then
      echo "  prefix ::/$len infinity;"
    fi

    id=0
    unset IFS
    for iname in $IPV6_PREFIX_DELEGATION; do
      int=""
      case $iname in
        INTIF)
          if [ -n "$INTIF" -a "$INTIF" != "none" -a -n "$INTIP" -a -n "$INTNM" ]; then
            int="$INTIF"
          fi
          ;;
        INT2IF)
          if [ -n "$INT2IF" -a "$INT2IF" != "none" -a -n "$INT2IP" -a -n "$INT2NM" ]; then
            int="$INT2IF"
          fi
          ;;
        INT3IF)
          if [ -n "$INT3IF" -a "$INT3IF" != "none" -a -n "$INT3IP" -a -n "$INT3NM" ]; then
            int="$INT3IF"
          fi
          ;;
        INT4IF)
          if [ -n "$INT4IF" -a "$INT4IF" != "none" -a -n "$INT4IP" -a -n "$INT4NM" ]; then
            int="$INT4IF"
          fi
          ;;
        DMZIF)
          if [ -n "$DMZIF" -a "$DMZIF" != "none" -a -n "$DMZIP" -a -n "$DMZNM" ]; then
            int="$DMZIF"
          fi
          ;;
      esac
      if [ -n "$int" ]; then
        echo "  prefix-interface $int {
    sla-id $id;
    sla-len $((64-len));
    ifid 1;
  };"
        id=$((id+1))

        # Only assign one interface given only a /64 prefix
        if [ $len -eq 64 ]; then
          break
        fi
      fi
    done

    # When no suitable internal interfaces are defined to receive
    # a prefix delegation, use a dummy interface named "ip6pd"
    if [ $id -eq 0 ]; then
      echo "  prefix-interface ip6pd {
    sla-id 0;
    sla-len $((64-len));
    ifid 1;
  };"
      dummy=1
    fi

    echo "};"
  fi

  return $dummy
}

init_dhcp6c()
{
  local iname="$1" interface="$2"

  sysctl -w net/ipv6/conf/${interface}/accept_ra=2 >/dev/null

  # Make DUID persistant
  ln -sf /mnt/kd/dhcp6c_duid /var/db/dhcp6c_duid

  if [ "$iname" = "ext2if" ]; then
    gen_nopd_dhcp6c_conf $interface > /etc/wide-dhcpv6/dhcp6c-${interface}.conf
  else
    gen_dhcp6c_conf $interface > /etc/wide-dhcpv6/dhcp6c-${interface}.conf
    if [ $? -eq 1 ]; then
      modprobe dummy numdummies=0
      ip link add name ip6pd type dummy
    fi
  fi
}

ipv6_tunnel()
{
  local action="$1" type local_addr remote_addr endpoint_addr

  type="$(echo $IPV6_TUNNEL | cut -d'~' -f1)"
  remote_addr="$(echo $IPV6_TUNNEL | cut -d'~' -f2)"
  endpoint_addr="$(echo $IPV6_TUNNEL | cut -d'~' -f3)"

  case $action in

    start)
      local_addr="$(find_ip_from_if "$EXTIF")"
      if [ -z "$local_addr" ]; then
        echo "ipv6_tunnel: Can't determine local external IPv4 address" >&2
        return
      elif [ -z "$remote_addr" -o -z "$endpoint_addr" ]; then
        echo "ipv6_tunnel: Empty IPV6_TUNNEL variable field(s)" >&2
        return
      fi
      case $type in
        6in4-static)
          ip tunnel add ip6tun mode sit remote $remote_addr local $local_addr ttl 255
          ip link set dev ip6tun up
          ip -6 addr add $endpoint_addr dev ip6tun
          ip -6 route add ::/0 dev ip6tun metric 1
          ;;
        6to4-relay)
          ip tunnel add ip6tun mode sit remote any local $local_addr ttl 255
          ip link set dev ip6tun up
          ip -6 addr add $endpoint_addr dev ip6tun
          ip -6 route add ::/0 via ::192.88.99.1 dev ip6tun metric 1
          ;;
        *)
          echo "ipv6_tunnel: Tunnel type \"$type\" is not supported." >&2
          ;;
      esac
      ;;

    stop)
      case $type in
        6in4-static|6to4-relay)
          ip -6 route flush dev ip6tun
          ip link set dev ip6tun down
          ip tunnel del ip6tun
          ;;
        *)
          echo "ipv6_tunnel: Tunnel type \"$type\" is not supported." >&2
          ;;
      esac
      ;;

  esac
}

alias_interface()
{
  local action="$1" interface="$2" alias_list="$3" cnt alias IFS

  case $action in

    add)
      cnt=1
      unset IFS
      for alias in $alias_list; do
        ip addr add $alias/32 dev $interface label ${interface}:${cnt}
        cnt=$((cnt+1))
      done
      ;;

    delete)
      unset IFS
      for alias in $alias_list; do
        ip addr delete $alias/32 dev $interface
      done
      ;;

  esac
}

phyeth_disable_offload()
{
  local eth off off_list="$1" IFS

  logger -s -t network -p kern.info "Disabling \"$off_list\" offload on all configured ethernet interfaces."

  unset IFS
  for eth in $EXTIF $EXT2IF $PPPOEIF $INTIF $INT2IF $INT3IF $INT4IF $DMZIF $BRIDGE0 $BRIDGE1 $BRIDGE2; do
    case $eth in
      eth*)
        for off in $off_list; do
          ethtool -K $eth $off off 2>/dev/null
        done
        ;;
    esac
  done
}

init () {

  mkdir -p /tmp/etc/wide-dhcpv6

  if [ -n "$IFRENAME" ]; then

    #clear existing iftabs
    : > /tmp/etc/iftab
    : > /tmp/etc/iftab.init

    #set COUNT
    COUNT=10

    for i in $IFRENAME; do
      IF="$(echo $i | cut -d: -f1)"
      DRIVER="$(echo $i | cut -d: -f2)"
      ID="$(echo $i | cut -d: -f3)"

      COUNT=$((COUNT-1))

      if echo $ID | grep -q i; then
        RID="$(echo $ID | tr -d i)"
        echo "eth$COUNT driver $DRIVER interrupt $RID" >> /tmp/etc/iftab.init
        echo "$IF driver $DRIVER interrupt $RID" >> /tmp/etc/iftab
      fi

    done
  fi

  if [ -f /etc/iftab.init ]; then
    echo "Remapping interfaces (init)..."
    ifrename -c /etc/iftab.init
  fi

  if [ -f /etc/iftab ]; then
    echo "Remapping interfaces..."
    ifrename -c /etc/iftab
  fi

  if [ -n "$PHYETH" ]; then
    for i in $PHYETH; do
      INT="$(echo $i | cut -d: -f1)"
      SPEED="$(echo $i | cut -d: -f2)"
      DUP="$(echo $i | cut -d: -f3)"

      echo "Setting ethernet parameters for $INT..."
      ethtool -s "$INT" speed "$SPEED" duplex "$DUP" autoneg off
    done
  fi
}

start () {
  local IF

  # IPv6
  if [ "$IPV6" = "yes" -o -n "$BRIDGE0" -o -n "$BRIDGE1" -o -n "$BRIDGE2" -o -n "$WIREGUARD_IP" ]; then
    modprobe ipv6
    # Disable IPv6 Autoconf by default
    IFS=$'\n'
    for line in $(sysctl -a 2>/dev/null | cut -d' ' -f1 | \
        grep -e "^net\.ipv6\.conf\..*\.autoconf$" \
             -e "^net\.ipv6\.conf\..*\.accept_ra$"); do
      sysctl -w "$line=0" >/dev/null
    done
    unset IFS
  fi

  SYS_gen_etc_hosts > /tmp/etc/hosts

  : > /tmp/etc/ethers

  if [ -f /stat/etc/ethers ]; then
    cat /stat/etc/ethers >> /tmp/etc/ethers
  fi

  if [ -f /mnt/kd/ethers ]; then
    cat /mnt/kd/ethers >> /tmp/etc/ethers
  fi

  ip addr add 127.0.0.1/8 dev lo scope host
  ip link set dev lo up

  # look for nas[0123] being any one of our interfaces, and create it
  for IF in $PPPOEIF $BRIDGE0 $BRIDGE1 $BRIDGE2 $INTIF $INT2IF $INT3IF $INT4IF; do
    case $IF in
    nas[0123])
      create_nasX $IF ;;
    esac
  done

  # if you want to change an interface's MAC address, you must do so
  # before marking it up or joining it to a bridge.
  if [ -n "$EXTIF" -a -n "$EXTIFMAC" -a "$EXTIF" != "none" ]; then
    case "$EXTIF" in
    br[0-2])
      ;;
    *)
      ip link set dev "$EXTIF" address $EXTIFMAC
      ;;
    esac
  fi

  if [ -n "$EXT2IF" -a -n "$EXT2IFMAC" -a "$EXT2IF" != "none" ]; then
    case "$EXT2IF" in
    br[0-2])
      ;;
    *)
      ip link set dev "$EXT2IF" address $EXT2IFMAC
      ;;
    esac
  fi

  #VLANS
  if [ -n "$VLANS" ]; then
    for i in $VLANS; do
      IF="$(echo $i | cut -d. -f1)"
      VID="$(echo $i | cut -d. -f2)"
      modprobe 8021q
      ip link add link $IF name $IF.$VID type vlan id $VID
      ip link set dev $IF up
      if [ "$VLANCOS" = "yes" ]; then
        vconfig set_egress_map "$IF.$VID" 0 3 > /dev/null
        vconfig set_egress_map "$IF.$VID" 1 3 > /dev/null
        vconfig set_egress_map "$IF.$VID" 2 1 > /dev/null
        vconfig set_egress_map "$IF.$VID" 3 1 > /dev/null
        vconfig set_egress_map "$IF.$VID" 4 4 > /dev/null
        vconfig set_egress_map "$IF.$VID" 5 5 > /dev/null
        vconfig set_egress_map "$IF.$VID" 6 6 > /dev/null
        vconfig set_egress_map "$IF.$VID" 7 7 > /dev/null
      fi
    done
  fi

  #BRIDGES
  if [ -n "$BRIDGE0" ]; then
    modprobe bridge
    ip link add name br0 type bridge
    for i in $BRIDGE0; do
      ip link set dev $i up
      ip link set dev $i master br0
    done
  fi

  if [ -n "$BRIDGE1" ]; then
    modprobe bridge
    ip link add name br1 type bridge
    for i in $BRIDGE1; do
      ip link set dev $i up
      ip link set dev $i master br1
    done
  fi

  if [ -n "$BRIDGE2" ]; then
    modprobe bridge
    ip link add name br2 type bridge
    for i in $BRIDGE2; do
      ip link set dev $i up
      ip link set dev $i master br2
    done
  fi

  # and now we retry applying the MAC address if it's a bridge interface.
  if [ -n "$EXTIF" -a -n "$EXTIFMAC" -a "$EXTIF" != "none" ]; then
    case "$EXTIF" in
    br[0-2])
      ip link set dev "$EXTIF" down
      ip link set dev "$EXTIF" address $EXTIFMAC
      ;;
    esac
  fi

  if [ -n "$EXT2IF" -a -n "$EXT2IFMAC" -a "$EXT2IF" != "none" ]; then
    case "$EXT2IF" in
    br[0-2])
      ip link set dev "$EXT2IF" down
      ip link set dev "$EXT2IF" address $EXT2IFMAC
      ;;
    esac
  fi

  if [ -n "$IFMTU" ]; then
    for i in $IFMTU; do
      IF="$(echo $i | cut -d: -f1)"
      MTU="$(echo $i | cut -d: -f2)"
      ip link set dev $IF mtu $MTU
    done
  fi

  if [ -n "$PHYETH_DISABLE_OFFLOAD" ]; then
    phyeth_disable_offload "$PHYETH_DISABLE_OFFLOAD"
  fi

  if [ -n "$INTIF" -a -n "$INTIP" -a -n "$INTNM" -a "$INTIF" != "none" ]; then
    ip addr add $INTIP/$INTNM brd + dev $INTIF
    if [ "$IPV6" = "yes" -a -n "$INTIPV6" ]; then
      ip -6 addr add $INTIPV6 dev $INTIF
    fi
    ip link set dev $INTIF up

    if [ "$NTPBROADCAST" = "yes" ]; then
      ip route add 224.0.0.0/4 dev $INTIF
    fi
  fi

  if [ -n "$INT2IF" -a -n "$INT2IP" -a -n "$INT2NM" -a "$INT2IF" != "none" ]; then
    ip addr add $INT2IP/$INT2NM brd + dev $INT2IF
    if [ "$IPV6" = "yes" -a -n "$INT2IPV6" ]; then
      ip -6 addr add $INT2IPV6 dev $INT2IF
    fi
    ip link set dev $INT2IF up
  fi

  if [ -n "$INT3IF" -a -n "$INT3IP" -a -n "$INT3NM" -a "$INT3IF" != "none" ]; then
    ip addr add $INT3IP/$INT3NM brd + dev $INT3IF
    if [ "$IPV6" = "yes" -a -n "$INT3IPV6" ]; then
      ip -6 addr add $INT3IPV6 dev $INT3IF
    fi
    ip link set dev $INT3IF up
  fi

  if [ -n "$INT4IF" -a -n "$INT4IP" -a -n "$INT4NM" -a "$INT4IF" != "none" ]; then
    ip addr add $INT4IP/$INT4NM brd + dev $INT4IF
    if [ "$IPV6" = "yes" -a -n "$INT4IPV6" ]; then
      ip -6 addr add $INT4IPV6 dev $INT4IF
    fi
    ip link set dev $INT4IF up
  fi

  if [ -n "$DMZIF" -a -n "$DMZIP" -a -n "$DMZNM" -a "$DMZIF" != "none" ]; then
    ip addr add $DMZIP/$DMZNM brd + dev $DMZIF
    if [ "$IPV6" = "yes" -a -n "$DMZIPV6" ]; then
      ip -6 addr add $DMZIPV6 dev $DMZIF
    fi
    ip link set dev $DMZIF up
  fi

  if [ -n "$WANDELAY" ]; then
    echo "Sleeping for $WANDELAY seconds before I bring up $EXTIF..."
    sleep $WANDELAY
  fi

  # PPPoE Again!
  if isextppp; then
    case $PPPOEIF in
    eth*|nas[0123])
      ip link set dev $PPPOEIF up ;;
    br[012])
      ip link set dev $PPPOEIF up
      # because bridging does weird and unpleasant things to PPPoE packets
      sysctl -w net/bridge/bridge-nf-call-iptables=0 >/dev/null
      sysctl -w net/bridge/bridge-nf-filter-pppoe-tagged=0 >/dev/null
      ;;
    esac

    mkdir /tmp/etc/ppp
    echo "ETH=$PPPOEIF
USER=$PPPOEUSER
DEMAND=no
DNSTYPE=SERVER
PEERDNS=yes
DNS1=
DEFAULTROUTE=yes
CONNECT_TIMEOUT=30
CONNECT_POLL=2
ACNAME=
SERVICENAME=
PING=\".\"
CONFIG=\"/etc/ppp/pppoe.conf\"
PIDFILE=\"/var/run/pppoe.conf-adsl.pid\"
SYNCHRONOUS=no
CLAMPMSS=1412
LCP_INTERVAL=20
LCP_FAILURE=3
PPPOE_TIMEOUT=80
FIREWALL=NONE
PPPOE_EXTRA=\"\"" > /tmp/etc/ppp/pppoe.conf

    PPPVER="$( (pppd --version 2>&1 >/dev/null ) | awk '/^pppd version/ { print $3; }')"

    if [ -n "$PPPOEKERNEL" ]; then
      echo "LINUX_PLUGIN=\"/usr/lib/pppd/$PPPVER/rp-pppoe.so\"" >> /tmp/etc/ppp/pppoe.conf
    else
      echo "LINUX_PLUGIN=\"\"" >> /tmp/etc/ppp/pppoe.conf
    fi

    PPPOE_PPPD_EXTRA="persist maxfail 0"

    if [ -n "$PPPOEDEBUG" ]; then
      if [ -n "$PPPOEKERNEL" ]; then
        PPPOE_PPPD_EXTRA="${PPPOE_PPPD_EXTRA} kdebug 1"
      fi
      PPPOE_PPPD_EXTRA="${PPPOE_PPPD_EXTRA} debug"
    fi
    echo "PPPD_EXTRA=\"${PPPOE_PPPD_EXTRA}\"" >> /tmp/etc/ppp/pppoe.conf

    echo "$PPPOEUSER * $PPPOEPASS" > /tmp/etc/ppp/pap-secrets
    echo "$PPPOEUSER * $PPPOEPASS" > /tmp/etc/ppp/chap-secrets
    chmod 600 /tmp/etc/ppp/chap-secrets /tmp/etc/ppp/pap-secrets

    echo "Attempting to bring up PPPoE on $PPPOEIF"
    echo "This could take some time..."

    if [ -x /usr/sbin/pppoe-start ]; then
      /usr/sbin/pppoe-start
    else
      /usr/sbin/adsl-start
    fi
    sleep 5

    #end PPPoE
  else
    rm -f /tmp/etc/ppp/pppoe.conf
  fi

  #Static IP Failover Interface
  if [ -n "$EXT2IP" -a -n "$EXT2IF" ] && ! isextppp ext2if; then

    case $EXT2IF in
    wp)
      ;;
    hdlc0|pvc0)
      ip tunnel add $EXT2IF mode ipip remote $EXT2GW local $EXT2IP
      ip link set dev $EXT2IF up
      ;;
    *)
      up_delay=0
      ip addr add $EXT2IP/$EXT2NM brd + dev $EXT2IF
      if [ -n "$EXT2IP_ALIAS" ]; then
        alias_interface add $EXT2IF "$EXT2IP_ALIAS"
      fi
      if [ "$IPV6" = "yes" ]; then
        if [ "$EXT2DHCPV6_CLIENT_ENABLE" = "yes" ]; then
          up_delay=4
          init_dhcp6c ext2if $EXT2IF
          ifplugd -apq -t2 -u3 -d3 -i $EXT2IF -r /etc/ifplugd/dhcp6c.action
        elif [ -n "$EXT2IPV6" ]; then
          ip -6 addr add $EXT2IPV6 dev $EXT2IF
        fi
      fi
      ip link set dev $EXT2IF up
      if [ $up_delay -gt 0 ]; then
        sleep $up_delay
      fi
      ;;
    esac

    if [ -n "$EXT2GW" ]; then
      for x in $EXT2ROUTES; do
        ip route add $x via $EXT2GW dev $EXT2IF
      done
    fi
    if [ "$IPV6" = "yes" -a -n "$EXT2GWIPV6" ]; then
      for x in $EXT2ROUTESIPV6; do
        ip -6 route add $x via $EXT2GWIPV6 dev $EXT2IF metric 1
      done
    fi
    #end static ip on 2nd if
  fi

  #Static IP
  if [ -n "$EXTIP" -a -n "$EXTIF" ] && ! isextppp extif; then

    case $EXTIF in
    wp)
      ;;
    hdlc0|pvc0)
      ip tunnel add $EXTIF mode ipip remote $EXTGW local $EXTIP
      ip link set dev $EXTIF up
      ;;
    *)
      up_delay=0
      ip addr add $EXTIP/$EXTNM brd + dev $EXTIF
      if [ -n "$EXTIP_ALIAS" ]; then
        alias_interface add $EXTIF "$EXTIP_ALIAS"
      fi
      if [ "$IPV6" = "yes" ]; then
        if [ "$DHCPV6_CLIENT_ENABLE" = "yes" ]; then
          up_delay=10
          init_dhcp6c extif $EXTIF
          ifplugd -apq -t2 -u3 -d3 -i $EXTIF -r /etc/ifplugd/dhcp6c.action
        fi
        if [ "$DHCPV6_CLIENT_ENABLE" != "yes" -o "$DHCPV6_CLIENT_REQUEST_ADDRESS" = "no" ]; then
          if [ -n "$EXTIPV6" ]; then
            ip -6 addr add $EXTIPV6 dev $EXTIF
          fi
        fi
      fi
      ip link set dev $EXTIF up
      while [ $up_delay -gt 0 ] && [ ! -f /var/db/dhcp6c_cache ]; do
        up_delay=$((up_delay - 1))
        sleep 1
      done
      ;;
    esac

    if [ -n "$EXTGW" ]; then
      ip route add default via $EXTGW dev $EXTIF
    fi
    if [ "$IPV6" = "yes" ] && [ "$DHCPV6_CLIENT_ENABLE" != "yes" -o "$DHCPV6_CLIENT_REQUEST_ADDRESS" = "no" ]; then
      if [ -n "$EXTIPV6" ]; then
        if [ -n "$EXTGWIPV6" ]; then
          ip -6 route add default via $EXTGWIPV6 dev $EXTIF metric 1
        else
          # Use Router Advertisements to set the default route
          sysctl -w net/ipv6/conf/${EXTIF}/accept_ra=2 >/dev/null
        fi
      fi
    fi
    #end static IP
  fi

  #DHCP Failover Interface
  if [ -n "$EXT2IF" -a -z "$EXT2IP" ] && ! isextppp ext2if; then
    if [ "$IPV6" = "yes" -a "$EXT2DHCPV6_CLIENT_ENABLE" = "yes" ]; then
      init_dhcp6c ext2if $EXT2IF
    fi
    ifplugd -apq -t2 -u3 -d3 -i $EXT2IF -r /etc/ifplugd/udhcpc.action
    ip link set dev $EXT2IF up
    sleep 4

    # No DHCPv6 - Static IPv6 if defined
    if [ "$IPV6" = "yes" ]; then
      if [ -n "$EXT2IPV6" -a "$EXT2DHCPV6_CLIENT_ENABLE" != "yes" ]; then
        ip -6 addr add $EXT2IPV6 dev $EXT2IF
      fi
      if [ -n "$EXT2GWIPV6" ]; then
        for x in $EXT2ROUTESIPV6; do
          ip -6 route add $x via $EXT2GWIPV6 dev $EXT2IF metric 1
        done
      fi
    fi
  fi

  #DHCP
  if [ -n "$EXTIF" -a -z "$EXTIP" ] && ! isextppp extif; then
    up_delay=0
    ip link set dev $EXTIF up
    sleep 4
    if [ "$IPV6" = "yes" -a "$DHCPV6_CLIENT_ENABLE" = "yes" ]; then
      up_delay=10
      init_dhcp6c extif $EXTIF
      dhcp6c -c /etc/wide-dhcpv6/dhcp6c-$EXTIF.conf -p /var/run/dhcp6c-$EXTIF.pid $EXTIF
    fi
    udhcpc -b -T2 -t6 -S -s /etc/udhcpc.script -H $HOSTNAME -p /var/run/udhcpc-$EXTIF.pid -i $EXTIF
    ifplugd -apq -t2 -u3 -d3 -i $EXTIF -r /etc/ifplugd/udhcpc.action
    while [ $up_delay -gt 0 ] && [ ! -f /var/db/dhcp6c_cache ]; do
      up_delay=$((up_delay - 1))
      sleep 1
    done

    # No DHCPv6 - Static IPv6 if defined
    if [ "$IPV6" = "yes" ] && [ "$DHCPV6_CLIENT_ENABLE" != "yes" -o "$DHCPV6_CLIENT_REQUEST_ADDRESS" = "no" ]; then
      if [ -n "$EXTIPV6" ]; then
        ip -6 addr add $EXTIPV6 dev $EXTIF
        if [ -n "$EXTGWIPV6" ]; then
          ip -6 route add default via $EXTGWIPV6 dev $EXTIF metric 1
        else
          # Use Router Advertisements to set the default route
          sysctl -w net/ipv6/conf/${EXTIF}/accept_ra=2 >/dev/null
        fi
      fi
    fi
  fi

  ##IPv6 Tunnel
  if [ "$IPV6" = "yes" -a -n "$IPV6_TUNNEL" ]; then
    ipv6_tunnel start
  fi

  echo "Network UP"
  sleep 1
}

stop () {
  local IF PID

  if [ "$IPV6" = "yes" -a -n "$IPV6_TUNNEL" ]; then
    echo "Bringing down IPv6 tunnel..."
    ipv6_tunnel stop
  fi

  for PID in $(ls -1 /var/run/ifplugd.*.pid 2>/dev/null); do
    echo "Stopping ifplugd..."
    kill $(cat "$PID")
  done

  for PID in $(ls -1 /var/run/dhcp6c-*.pid 2>/dev/null); do
    echo "Stopping dhcp6c..."
    kill $(cat "$PID")
  done

  for PID in $(ls -1 /var/run/udhcpc-*.pid 2>/dev/null); do
    echo "Stopping udhcpc..."
    kill $(cat "$PID")
  done

  if [ -f /var/run/ppp0.pid ]; then
    kill $(cat /var/run/ppp0.pid)
  fi

  if [ -n "$EXTIF" -a "$EXTIF" != "none" ]; then
    echo "Bringing down $EXTIF..."
    if [ -n "$EXTIP_ALIAS" ]; then
      alias_interface delete $EXTIF "$EXTIP_ALIAS"
    fi
    ip link set dev $EXTIF down
  fi

  if [ -n "$EXT2IF" -a "$EXT2IF" != "none" ]; then
    echo "Bringing down $EXT2IF..."
    if [ -n "$EXT2IP_ALIAS" ]; then
      alias_interface delete $EXT2IF "$EXT2IP_ALIAS"
    fi
    ip link set dev $EXT2IF down
  fi

  if [ -n "$INTIF" -a "$INTIF" != "none" ]; then
    echo "Bringing down $INTIF..."
    ip link set dev $INTIF down
  fi

  if [ -n "$INT2IF" -a "$INT2IF" != "none" ]; then
    echo "Bringing down $INT2IF ..."
    ip link set dev $INT2IF down
  fi

  if [ -n "$INT3IF" -a "$INT3IF" != "none" ]; then
    echo "Bringing down $INT3IF..."
    ip link set dev $INT3IF down
  fi

  if [ -n "$INT4IF" -a "$INT4IF" != "none" ]; then
    echo "Bringing down $INT4IF..."
    ip link set dev $INT4IF down
  fi

  if [ -n "$DMZIF" -a "$DMZIF" != "none" ]; then
    echo "Bringing down $DMZIF ..."
    ip link set dev $DMZIF down
  fi

  #BRIDGES
  if [ -n "$BRIDGE0" ]; then
    ip link set dev br0 down
    for i in $BRIDGE0; do
      ip link set dev $i nomaster
      ip link set dev $i down
    done
    ip link delete br0 type bridge
  fi

  if [ -n "$BRIDGE1" ]; then
    ip link set dev br1 down
    for i in $BRIDGE1; do
      ip link set dev $i nomaster
      ip link set dev $i down
    done
    ip link delete br1 type bridge
  fi

  if [ -n "$BRIDGE2" ]; then
    ip link set dev br2 down
    for i in $BRIDGE2; do
      ip link set dev $i nomaster
      ip link set dev $i down
    done
    ip link delete br2 type bridge
  fi

  #VLANS
  if [ -n "$VLANS" ]; then
    for i in $VLANS; do
      ip link set dev $i down
      ip link delete $i
    done
  fi

  # ATM interfaces
  for IF in $PPPOEIF $BRIDGE0 $BRIDGE1 $BRIDGE2 $INTIF $INT2IF $INT3IF $INT4IF; do
    case $IF in
    nas[0123])
      ip link set dev "$IF" down
      killall br2684ctl
      if [ -n "$ATM_MODULE" ]; then
        modprobe -r $ATM_MODULE
      fi
      break			# only need to do this once
      ;;
    esac
  done

  echo "Network DOWN"
}

case $1 in

start)
  start
  ;;

stop)
  stop
  ;;

init)
  init
  start
  ;;

restart)
  stop
  sleep 2
  start
  ;;

*)
  echo "Usage: start|stop|restart"
  ;;

esac

